
//Parts of the code in this file are copied or adopted from utf8-cpp, which had the following copyright notice.

    // Copyright 2006 Nemanja Trifunovic

    /*
    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
    */

#pragma once

#include "dfgDefs.hpp"
DFG_BEGIN_INCLUDE_WITH_DISABLED_WARNINGS
    #include "utf/utf8_cpp/utf8.h"
DFG_END_INCLUDE_WITH_DISABLED_WARNINGS
#include "utf/utfBom.hpp"
#include "dfgBase.hpp" // For byteorder
#include "io/textEncodingTypes.hpp"
#include <iterator>
#include <limits>
#include <type_traits>
#include "dfgAssert.hpp"

DFG_ROOT_NS_BEGIN{ DFG_SUB_NS(utf) {

    const uint32 INVALID_CODE_POINT = utf8::internal::CODE_POINT_MAX + 1;

    namespace DFG_DETAIL_NS
    {
        const int8 gDefaultUnrepresentableCharReplacementAscii = '?';
        const uint16 gDefaultUnrepresentableCharReplacementUtf = 0xfffd;

        template <class Iter_T, bool HasVoidValueType> struct EffectiveIteratorValueTypeHelper
        {
            typedef typename Iter_T::value_type type;
        };

        template <class Iter_T> struct EffectiveIteratorValueTypeHelper<Iter_T, true>
        {
            typedef typename Iter_T::container_type::value_type type;
        };

        // Defines 'type' as
        //	1. std::iterator_traits<Iter_T>::value_type, if Iter_T has non-void value_type
        //	2. typename Iter_T::container_type::value_type, if Iter_T has void value type (e.g. in case of back inserters)
        // For related code, HAS_TYPEDEF in http://stackoverflow.com/questions/257288/is-it-possible-to-write-a-c-template-to-check-for-a-functions-existence/19815793#19815793
        template <class Iter_T> struct EffectiveIteratorValueType
        {
            static const bool HasVoidValueType = std::is_same<void, typename std::iterator_traits<Iter_T>::value_type>::value;
            typedef typename EffectiveIteratorValueTypeHelper<Iter_T, HasVoidValueType>::type type;
        };

        // Specialization for T*
        template <class T> struct EffectiveIteratorValueType<T*>
        {
            typedef T type;
        };

        // Based on https://en.wikipedia.org/wiki/Windows-1252
        const uint32_t windows1252charToCpConversionTable_0x80_to_0x9f[] =
                             { 0x20AC, gDefaultUnrepresentableCharReplacementUtf, 0x201A, 0x192, 0x201E, 0x2026, 0x2020, 0x2021,
                               0x2C6, 0x2030, 0x160, 0x2039, 0x152, gDefaultUnrepresentableCharReplacementUtf, 0x17D, gDefaultUnrepresentableCharReplacementUtf,
                               gDefaultUnrepresentableCharReplacementUtf, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
                               0x2DC, 0x2122, 0x161, 0x203A, 0x153, gDefaultUnrepresentableCharReplacementUtf, 0x17E, 0x178 };
    } // DFG_DETAIL_NS

    struct UnconvertableCpHandlerParam
    {
        explicit UnconvertableCpHandlerParam(uint32 c) :
            cp(c)
        {}
        uint32 cp;
    };

    inline uint32 defaultUnconvertableCpHandler(UnconvertableCpHandlerParam param)
    {
        DFG_UNUSED(param);
        return DFG_DETAIL_NS::gDefaultUnrepresentableCharReplacementAscii;
    }

template <typename octet_iterator>
inline typename std::iterator_traits<octet_iterator>::difference_type
sequence_length(octet_iterator lead_it)
{
    uint8_t lead = utf8::internal::mask8(*lead_it);
    if (lead < 0x80)
        return 1;
    else if ((lead >> 5) == 0x6)
        return 2;
    else if ((lead >> 4) == 0xe)
        return 3;
    else if ((lead >> 3) == 0x1e)
        return 4;
    else
        return 0;
}

// Returns true iff given codepoint is valid.
inline bool isCodePointValid(const uint32 cp)
{
    return utf8::internal::is_code_point_valid(cp);
}

template <typename octet_iterator>
uint32_t next(octet_iterator& it, const octet_iterator& itEnd)
{
    using utf8::internal::mask8;
    if (it == itEnd)
        return INVALID_CODE_POINT;
    uint32_t cp = mask8(*it);
    const auto length = sequence_length(it);
    if (length == 0)
    {
        // Getting here means that lead byte was not valid ->
        // simply skip to next code unit and return replacement char.
        ++it;
        return DFG_DETAIL_NS::gDefaultUnrepresentableCharReplacementUtf;
    }
    if (std::distance(it, itEnd) < length)
    {
        it = itEnd;
        return INVALID_CODE_POINT;
    }
    uint32 nMask = 0x80;
    uint32 nExpectedMaskResult = 0;
    uint32 nMinValue = 0;
    uint32 nSequenceValue = cp;
    switch (length) {
    case 1:
        break;
    case 2:
        it++;
        cp = ((cp << 6) & 0x7ff) + ((*it) & 0x3f);
        nSequenceValue <<= 8; nSequenceValue += mask8(*it);
        nMask = 0xE0C0;               // 11100000 11000000
        nExpectedMaskResult = 0xC080; // 11000000 10000000
        nMinValue = 128;
        break;
    case 3:
        ++it;
        cp = ((cp << 12) & 0xffff) + ((mask8(*it) << 6) & 0xfff);
        nSequenceValue <<= 8; nSequenceValue += mask8(*it);
        ++it;
        cp += (*it) & 0x3f;
        nSequenceValue <<= 8; nSequenceValue += mask8(*it);
        nMask = 0xF0C0C0;               // 11110000 11000000 11000000
        nExpectedMaskResult = 0xE08080; // 11100000 10000000 10000000
        nMinValue = 0x800;
        break;
    case 4:
        ++it;
        cp = ((cp << 18) & 0x1fffff) + ((mask8(*it) << 12) & 0x3ffff);
        nSequenceValue <<= 8; nSequenceValue += mask8(*it);
        ++it;
        cp += (mask8(*it) << 6) & 0xfff;
        nSequenceValue <<= 8; nSequenceValue += mask8(*it);
        ++it;
        cp += (*it) & 0x3f;
        nSequenceValue <<= 8; nSequenceValue += mask8(*it);
        nMask = 0xF8C0C0C0;               // 11111000 11000000 11000000 11000000
        nExpectedMaskResult = 0xF0808080; // 11110000 10000000 10000000 10000000
        nMinValue = 0x10000;
        break;
    }
    ++it;

    // Checking that sequence had proper form and is not overlong encoding
    if ((nSequenceValue & nMask) == nExpectedMaskResult &&
        cp >= nMinValue && isCodePointValid(cp))
        return cp;
    else
        return DFG_DETAIL_NS::gDefaultUnrepresentableCharReplacementUtf;
}

// Code point to UTF-8
// TODO: test, especially the byte order handling
template <typename IterUtf_T>
uint32 cpToUtf(const uint32 cp, IterUtf_T result, std::integral_constant<size_t, 8>, ByteOrder boDest = ByteOrderHost)
{
    DFG_UNUSED(boDest);
    constexpr auto outputCharSize = sizeof(typename DFG_DETAIL_NS::EffectiveIteratorValueType<IterUtf_T>::type);
    DFG_STATIC_ASSERT(outputCharSize == 1, "Iterator value type should be one byte wide.");
    utf8::unchecked::append(cp, result);
    return cp;
}

// Code point to UTF-16
// TODO: test, especially the byte order handling
template <typename IterUtf_T>
uint32 cpToUtf(const uint32 cp, IterUtf_T result, std::integral_constant<size_t, 16>, ByteOrder boDest)
{
#ifdef _MSC_VER
    #pragma warning(push)
    #pragma warning(disable:4244) // Conversion warnings.
    #pragma warning(disable:4127) // Conditional expression is constant
#endif

    const auto outputCharSize = sizeof(typename DFG_DETAIL_NS::EffectiveIteratorValueType<IterUtf_T>::type);
    DFG_STATIC_ASSERT(outputCharSize == 2, "Iterator value type should be two bytes wide.");
    if (cp > 0xffff) //make a surrogate pair
    {
        *result++ = byteSwap(static_cast<uint16_t>((cp >> 10) + utf8::internal::LEAD_OFFSET), ByteOrderHost, boDest);
        *result++ = byteSwap(static_cast<uint16_t>((cp & 0x3ff) + utf8::internal::TRAIL_SURROGATE_MIN), ByteOrderHost, boDest);
    }
    else
        *result++ = byteSwap(static_cast<uint16_t>(cp), ByteOrderHost, boDest);
    return cp;

#ifdef _MSC_VER
    #pragma warning(pop)
#endif
}

// Code point to UTF-32
// TODO: test, especially the byte order handling
template <typename IterUtf_T>
uint32 cpToUtf(const uint32 cp, IterUtf_T result, std::integral_constant<size_t, 32>, ByteOrder boDest)
{
#ifdef _MSC_VER
    #pragma warning(push)
    #pragma warning(disable:4242) // Conversion warnings. Disabling this warning seems to have broken with VC2022.2
    #pragma warning(disable:4244) // Conversion warnings.
    #pragma warning(disable:4127) // Conditional expression is constant
#endif
    using OutputT = typename DFG_DETAIL_NS::EffectiveIteratorValueType<IterUtf_T>::type;
    const auto outputCharSize = sizeof(OutputT);
    DFG_STATIC_ASSERT(outputCharSize == 4, "Iterator value type should be four bytes wide.");
    *result++ = static_cast<OutputT>(byteSwap(cp, ByteOrderHost, boDest));
    return cp;

#ifdef _MSC_VER
    #pragma warning(pop)
#endif
}

template <typename IterUtf_T>
uint32 cpToUtf(const uint32 cp, IterUtf_T result, const size_t encodedChSize, ByteOrder boDest)
{
    constexpr size_t outputTypeSize = sizeof(typename DFG_DETAIL_NS::EffectiveIteratorValueType<IterUtf_T>::type);
    if constexpr (outputTypeSize != 1)
    {
        if (outputTypeSize != encodedChSize)
        {
            DFG_ASSERT_WITH_MSG(false, "This function expects either byte output or output whose character size matches with encoding.");
            return INVALID_CODE_POINT;
        }
    }

    if (!utf8::internal::is_code_point_valid(cp))
        return cpToUtf(DFG_DETAIL_NS::gDefaultUnrepresentableCharReplacementUtf, result, encodedChSize, boDest);

    if (encodedChSize == 1)
    {
        if constexpr (outputTypeSize == 1)
            return cpToUtf(cp, result, std::integral_constant<size_t, 8>(), boDest);
        else
        {
            DFG_ASSERT_WITH_MSG(false, "cpToUtf: mismatching data type sizes");
            return INVALID_CODE_POINT;
        }
    }
    else if (encodedChSize == 2)
    {
        if constexpr (outputTypeSize == 2)
            return cpToUtf(cp, result, std::integral_constant<size_t, 16>(), boDest);
        else // byte output
        {
            std::vector<uint16> vec; // TODO: replace with static capacity version.
            const auto rv = cpToUtf(cp, std::back_inserter(vec), std::integral_constant<size_t, 16>(), boDest);
            if (rv == INVALID_CODE_POINT)
                return INVALID_CODE_POINT;
            for (size_t i = 0; i < vec.size() * sizeof(uint16); ++i)
            {
                *result++ = *(reinterpret_cast<const char*>(vec.data()) + i);
            }
            return rv;
        }
    }
    else if (encodedChSize == 4)
    {
        if constexpr (outputTypeSize == 4)
            return cpToUtf(cp, result, std::integral_constant<size_t, 32>(), boDest);
        else // byte output
        {
            uint32 val;
            const auto rv = cpToUtf(cp, &val, std::integral_constant<size_t, 32>(), boDest);
            if (rv == INVALID_CODE_POINT)
                return INVALID_CODE_POINT;
            auto p = reinterpret_cast<const char*>(&val);
            *result++ = *p++;
            *result++ = *p++;
            *result++ = *p++;
            *result++ = *p++;
            return rv;
        }
    }
    else
    {
        DFG_ASSERT(false); // Should not reach here.
        return INVALID_CODE_POINT;
    }
}

template <typename IterUtf_T>
uint32 cpToLatin1(const uint32 cp, IterUtf_T result, const uint8 unrepresentableFiller = DFG_DETAIL_NS::gDefaultUnrepresentableCharReplacementAscii)
{
    const auto cpEffective = (cp < 256) ? static_cast<uint8>(cp) : unrepresentableFiller;
    *result++ = cpEffective;
    return cpEffective;
}
 
/**
 * Writes given unicode codepoint to output iterator using given encoding.
 * @param cp Unicode codepoint
 * @param result Output iterator to write given character to.
 * @param encoding Encoding to use when writing codepoint to output iterator.
 *        Supported encodings:
 *            -All UTF encodings
 *            -Latin1
 * @return Returns codepoint that was written or if nothing was written, INVALID_CODE_POINT
 * @note If 'cp' is not a valid codepoint, an unspecified replacement character valid in chosen encoding will be written.
 */
template <typename IterUtf_T>
uint32 cpToEncoded(const uint32 cp, IterUtf_T result, const ::DFG_MODULE_NS(io)::TextEncoding encoding)
{
    using namespace DFG_MODULE_NS(io);

    //const size_t outputTypeSize = sizeof(typename DFG_DETAIL_NS::EffectiveIteratorValueType<IterUtf_T>::type);

    if (encoding == encodingLatin1)
    {
        return cpToLatin1(cp, result);
    }

    if (!isUtfEncoding(encoding))
    {
        DFG_ASSERT_IMPLEMENTED(false);
        return INVALID_CODE_POINT;
    }

    const ByteOrder bo = (isBigEndianEncoding(encoding)) ? ByteOrderBigEndian : ByteOrderLittleEndian;
    const auto baseChSize = baseCharacterSize(encoding);

    return cpToUtf(cp, result, baseChSize, bo);
}


template <typename u16bit_iterator, typename BswapFunc>
uint32_t readUtf16CharAndAdvance(u16bit_iterator& start, const u16bit_iterator end, BswapFunc bswap)
{
    if (start == end)
        return INVALID_CODE_POINT;
    DFG_STATIC_ASSERT(sizeof(*start) == 2, "Expecting iterator to return 16-bit values");
    uint32_t cp = utf8::internal::mask16(bswap(*start++));
    
    // Take care of surrogate pairs first
    if (utf8::internal::is_lead_surrogate(cp))
    {
        if (start == end)
            return INVALID_CODE_POINT;
        const uint32_t trail_surrogate = utf8::internal::mask16(bswap(*start++));
        if (utf8::internal::is_trail_surrogate(trail_surrogate))
            cp = (cp << 10) + trail_surrogate + utf8::internal::SURROGATE_OFFSET;
        else // Case: have lead surrogate but no trail surrogate, simply treat the whole pair as invalid.
            cp = DFG_DETAIL_NS::gDefaultUnrepresentableCharReplacementUtf;
    }
    return (isCodePointValid(cp)) ? cp : DFG_DETAIL_NS::gDefaultUnrepresentableCharReplacementUtf;
}

template <typename u32bit_iterator, typename BswapFunc>
uint32_t readUtf32CharAndAdvance(u32bit_iterator& start, u32bit_iterator end, BswapFunc bswap)
{
    DFG_STATIC_ASSERT(sizeof(*start) == 4, "Expecting iterator to return 32-bit values");

    if (start == end)
        return INVALID_CODE_POINT;
    return bswap(*start++);
}

template <typename CharIterator, typename BswapFunc>
uint32_t readUtfCharAndAdvanceImpl(CharIterator& start, const CharIterator end, BswapFunc, std::integral_constant<int, 1>)
{
    return next(start, end);
}

template <typename CharIterator, typename BswapFunc>
uint32_t readUtfCharAndAdvanceImpl(CharIterator& start, const CharIterator end, BswapFunc bswap, std::integral_constant<int,2>)
{
    return readUtf16CharAndAdvance(start, end, bswap);
}

template <typename CharIterator, typename BswapFunc>
uint32_t readUtfCharAndAdvanceImpl(CharIterator& start, const CharIterator end, BswapFunc bswap, std::integral_constant<int, 4>)
{
    return readUtf32CharAndAdvance(start, end, bswap);
}

template <typename CharIterator, typename BswapFunc>
uint32_t readUtfCharAndAdvance(CharIterator& start, const CharIterator end, BswapFunc bswap)
{
    return readUtfCharAndAdvanceImpl(start, end, bswap, std::integral_constant<int, sizeof(*start)>());
}

template <typename CharIterator>
uint32_t readUtfCharAndAdvance(CharIterator& start, const CharIterator end)
{
    constexpr auto baseCharSize = sizeof(*start);
    DFG_STATIC_ASSERT(baseCharSize == 1, "This overload is available only for 8-bit base characters");
    return readUtfCharAndAdvance(start, end, []() {});
}

// Converts given iterable of utf8 values to Latin-1 representation. When code point is out of range [0, 255],
// UnconvertableHandler will be invoked.
// TODO: test filling
template <class Iterable_T, class OutIter_T, class UnconvertableHandler_T>
void utf8ToLatin1Iter(const Iterable_T& source, OutIter_T dest, UnconvertableHandler_T uch = defaultUnconvertableCpHandler)
{
    auto iter = std::begin(source);
    const auto iterEnd = std::end(source);
    if (iter == iterEnd)
        return;
    for (; iter != iterEnd;)
    {
        uint32 cp = next(iter, iterEnd);
        if (cp < 256)
            *(dest++) = char(cp);
        else
            *(dest++) = static_cast<char>(uch(UnconvertableCpHandlerParam(cp)));
    }
}

// Convert iterable utf8 to latin1 and returns the string.
// TODO: test filling
template <class Iterable_T, class UnconvertableHandler_T>
std::string utf8ToLatin1(const Iterable_T& source, UnconvertableHandler_T uch)
{
    std::string s;
    utf8ToLatin1Iter(source, std::back_inserter(s), uch);
    return s;
}

// Convert iterable utf8 to latin1 and returns the string.
// TODO: test filling
template <class Iterable_T>
std::string utf8ToLatin1(const Iterable_T& source)
{
    return utf8ToLatin1(source, defaultUnconvertableCpHandler);
}

// TODO: test
template <class IterableUtf8_T, class IterOutUtf16_T>
void utf8To16Native(const IterableUtf8_T& source, IterOutUtf16_T dest)
{
    utf8::utf8to16(std::begin(source), std::end(source), dest);
}

// TODO: test
template <class IterableUtf8_T, class IterOutUtf32_T>
void utf8To32Native(const IterableUtf8_T& source, IterOutUtf32_T dest)
{
    utf8::utf8to32(std::begin(source), std::end(source), dest);
}

// Converts utfx-iterable to fixed size string, either Latin1, UCS-2 or UCS-4.
// TODO: test, especially the byte order handling
// TODO: DestType is redundant in many cases; it is there because getting output type from back_inserters is not 
//       the same as getting it from ordinary iterators. TODO: remove it by using EffectiveIteratorValueType.
template <class DestType, class IterableUtf_T, class IterOut_T, class UnconvertableHandler_T>
void utfToFixedChSizeStrIter(const IterableUtf_T& source, IterOut_T dest, ByteOrder boSource, ByteOrder boDest, UnconvertableHandler_T uch)
{
    auto iter = std::begin(source);
    const auto iterEnd = std::end(source);
    if (iter == iterEnd)
        return;
    typedef decltype(*iter) SourceT;
    typedef typename std::make_unsigned<DestType>::type UnsignedDestType;
    const auto sourceBo = [&](SourceT ch){return byteSwap(ch, boSource, ByteOrderHost); };
    for (; iter != iterEnd;)
    {
        uint32 cp = readUtfCharAndAdvanceImpl(iter, iterEnd, sourceBo, std::integral_constant<int, sizeof(*iter)>());
        if (cp <= (std::numeric_limits<UnsignedDestType>::max)())
            *(dest++) = byteSwap(static_cast<UnsignedDestType>(cp), ByteOrderHost, boDest);
        else
            *(dest++) = static_cast<UnsignedDestType>(uch(UnconvertableCpHandlerParam(cp)));
    }
}

// Converts utf8-iterable to fixed size string, either Latin1, UCS-2 or UCS-4.
// TODO: test, especially the byte order handling
template <class DestType, class IterableUtf8_T, class IterOut_T, class UnconvertableHandler_T>
void utf8ToFixedChSizeStrIter(const IterableUtf8_T& source, IterOut_T dest, ByteOrder bo, UnconvertableHandler_T uch)
{
    DFG_STATIC_ASSERT(sizeof(decltype(*std::begin(source))) == 1, "Element type of source is expected to have size of single byte");
    utfToFixedChSizeStrIter<DestType>(source, dest, ByteOrderHost, bo, uch);
}

// Overload for convenience.
template <class Char_T, class IterableUtf8_T, class UnconvertableHandler_T>
std::basic_string<Char_T> utf8ToFixedChSizeStr(const IterableUtf8_T& source, ByteOrder bo, UnconvertableHandler_T uch)
{
    std::basic_string<Char_T> str;
    utf8ToFixedChSizeStrIter<Char_T>(source, std::back_inserter(str), bo, uch);
    return str;
}

// Overload for convenience.
template <class Char_T, class IterableUtf8_T>
std::basic_string<Char_T> utf8ToFixedChSizeStr(const IterableUtf8_T& source, ByteOrder bo = ByteOrderHost)
{
    return utf8ToFixedChSizeStr<Char_T>(source, bo, defaultUnconvertableCpHandler);
}

// TODO: test, especially the byte order handling
template <class IterableUtf16_T, class IterOutUtf8_T>
void utf16To8(const IterableUtf16_T& source, IterOutUtf8_T dest, ByteOrder boSource = ByteOrderHost)
{
    auto iter = std::begin(source);
    const auto iterEnd = std::end(source);
    const auto bs = [&](uint16 cp) {return byteSwap(cp, boSource, ByteOrderHost); };
    for (; !isAtEnd(iter, iterEnd); )
    {
        const auto cp = readUtf16CharAndAdvance(iter, iterEnd, bs);
        ::utf8::unchecked::append(cp, dest);
    }	
}

// TODO: test, especially the byte order handling
template <class IterableUtf16_T, class IterOutUtf32_T>
void utf16To32(const IterableUtf16_T& source, IterOutUtf32_T dest, const ByteOrder boSource = ByteOrderHost, const ByteOrder boDest = ByteOrderHost)
{
    DFG_STATIC_ASSERT(sizeof(decltype(*std::begin(source))) == 2, "Element type of source is expected to have size of two bytes");
    auto iter = std::begin(source);
    const auto iterEnd = std::end(source);
    const auto bs = [&](uint16 cp) {return byteSwap(cp, boSource, ByteOrderHost); };
    for (; iter != iterEnd;)
    {
        const auto cp = readUtf16CharAndAdvance(iter, iterEnd, bs);
        *(dest++) = byteSwap(uint32(cp), ByteOrderHost, boDest);
    }
}

// TODO: test, especially the byte order handling
template <class DestType, class IterableUtf16_T, class IterOut_T, class UnconvertableHandler_T>
void utf16ToFixedChSizeStrIter(const IterableUtf16_T& source, IterOut_T dest, UnconvertableHandler_T uch, ByteOrder boSource = ByteOrderHost, ByteOrder boDest = ByteOrderHost)
{
    DFG_STATIC_ASSERT(sizeof(decltype(*std::begin(source))) == 2, "Element type of source is expected to have size of two bytes");
    utfToFixedChSizeStrIter<DestType>(source, dest, boSource, boDest, uch);
}

// Overload for convenience.
template <class Char_T, class IterableUtf16_T, class UnconvertableHandler_T>
std::basic_string<Char_T> utf16ToFixedChSizeStr(const IterableUtf16_T& source, ByteOrder boSource, ByteOrder boDest, UnconvertableHandler_T uch)
{
    std::basic_string<Char_T> str;
    utf16ToFixedChSizeStrIter<Char_T>(source, std::back_inserter(str), uch, boSource, boDest);
    return str;
}

// Overload for convenience.
template <class Char_T, class IterableUtf16_T>
std::basic_string<Char_T> utf16ToFixedChSizeStr(const IterableUtf16_T& source, ByteOrder boSource = ByteOrderHost, ByteOrder boDest = ByteOrderHost)
{
    return utf16ToFixedChSizeStr<Char_T>(source, boSource, boDest, defaultUnconvertableCpHandler);
}

// TODO: test, especially the byte order handling
template <class IterableUtf32_T, class IterOutUtf8_T>
void utf32To8(const IterableUtf32_T& source, IterOutUtf8_T dest, const ByteOrder boSource = ByteOrderHost)
{
    DFG_STATIC_ASSERT(sizeof(decltype(*std::begin(source))) == 4, "Element type of source is expected to have size of 4 bytes");
    auto iter = std::begin(source);
    const auto iterEnd = std::end(source);
    const auto bs = [&](uint32 cp) {return byteSwap(cp, boSource, ByteOrderHost); };
    for (; iter != iterEnd;)
    {
        const auto cp = readUtf32CharAndAdvance(iter, iterEnd, bs);
        ::utf8::unchecked::append(cp, dest);
    }
}

// TODO: test, especially the byte order handling
template <class IterableUtf32_T, class IterOutUtf16_T>
void utf32To16(const IterableUtf32_T& source, IterOutUtf16_T dest, const ByteOrder boSource = ByteOrderHost, const ByteOrder boDest = ByteOrderHost)
{
    DFG_STATIC_ASSERT(sizeof(decltype(*std::begin(source))) == 4, "Element type of source is expected to have size of 4 bytes");
    auto iter = std::begin(source);
    const auto iterEnd = std::end(source);
    const auto bs = [&](uint32 cp) {return byteSwap(cp, boSource, ByteOrderHost); };
    for (; iter != iterEnd;)
    {
        const auto cp = readUtf32CharAndAdvance(iter, iterEnd, bs);
        cpToUtf(cp, dest, std::integral_constant<size_t, 16>(), boDest);
    }
}

// TODO: test, especially the byte order handling
template <class DestType, class IterableUtf32_T, class IterOut_T, class UnconvertableHandler_T>
void utf32ToFixedChSizeStrIter(const IterableUtf32_T& source, IterOut_T dest, ByteOrder boSource, ByteOrder boDest, UnconvertableHandler_T uch)
{
    DFG_STATIC_ASSERT(sizeof(decltype(*std::begin(source))) == 4, "Element type of source is expected to have size of 4 bytes");
    utfToFixedChSizeStrIter<DestType>(source, dest, boSource, boDest, uch);
}

// Overload for convenience.
template <class Char_T, class IterableUtf32_T, class UnconvertableHandler_T>
std::basic_string<Char_T> utf32ToFixedChSizeStr(const IterableUtf32_T& source, ByteOrder boSource, ByteOrder boDest, UnconvertableHandler_T uch)
{
    std::basic_string<Char_T> str;
    utf32ToFixedChSizeStrIter<Char_T>(source, std::back_inserter(str), boSource, boDest, uch);
    return str;
}

// Overload for convenience.
template <class Char_T, class IterableUtf32_T>
std::basic_string<Char_T> utf32ToFixedChSizeStr(const IterableUtf32_T& source, ByteOrder boSource = ByteOrderHost, ByteOrder boDest = ByteOrderHost)
{
    return utf32ToFixedChSizeStr<Char_T>(source, boSource, boDest, defaultUnconvertableCpHandler);
}

// TODO: test, especially the byte order handling
template <class DestChar_T, class Iterable_T, class OutIter_T>
void codePointsToUtf(const Iterable_T& iterableCps, OutIter_T dest, ByteOrder boSource = ByteOrderHost, ByteOrder boDest = ByteOrderHost)
{
    const auto iterEnd = std::end(iterableCps);
    typedef typename std::make_unsigned<typename std::remove_reference<decltype(*iterEnd)>::type>::type UnsignedSourceChar;
    for (auto iter = std::begin(iterableCps); iter != iterEnd; ++iter)
    {
        const auto ch = static_cast<UnsignedSourceChar>(*iter); // This is for negative char values; automatically convert them to uint8.
        const uint32 cp = byteSwap(ch, boSource, ByteOrderHost);
        cpToUtf(cp, dest, std::integral_constant<size_t, sizeof(DestChar_T) * 8>(), boDest);
    }
}

template <class Iterable_T>
std::string codePointsToUtf8(const Iterable_T& iterableCps, ByteOrder boSource = ByteOrderHost)
{
    std::string str;
    codePointsToUtf<char>(iterableCps, std::back_inserter(str), boSource);
    return str;
}

template <class Iterable_T>
std::string codePointsToLatin1(const Iterable_T& iterableCps, ByteOrder boSource = ByteOrderHost)
{
    return utf8ToLatin1(codePointsToUtf8(iterableCps, boSource));
}

// Converts given iterable of latin1 values to utf8 representation and writes them to output iterator dest.
// Negative values are interpreted as uint8-values.
template <class Iterable_T, class OutIter_T>
void latin1ToUtf8(const Iterable_T& iterable, OutIter_T dest)
{
    codePointsToUtf8(iterable, dest);
}

// Overload for convenience returning string with utf8-encoded data.
template <class Iterable_T>
std::string latin1ToUtf8(const Iterable_T& iterable)
{
    return codePointsToUtf8(iterable);
}

inline uint32_t windows1252charToCp(const uint8 charValue)
{
    if (charValue < 0x80)
        return charValue;
    else if (charValue < 0xA0)
    {
        DFG_STATIC_ASSERT(DFG_COUNTOF(DFG_DETAIL_NS::windows1252charToCpConversionTable_0x80_to_0x9f) == 32, "Conversion table has wrong size");
        return DFG_DETAIL_NS::windows1252charToCpConversionTable_0x80_to_0x9f[charValue - 0x80];
    }
    else 
        return charValue;
}

inline uint32_t windows1252charToCp(const char charValue)
{
    return windows1252charToCp(static_cast<uint8>(charValue));
}

}} // module namespace
